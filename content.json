{"meta":{"title":"小菜的博客","subtitle":"就算失败99次，我也要努力凑个整数","description":"武昌工学院 | 软件工程 |编程算法学习","author":"小菜 C语言 黑苹果","url":"https://xckadpym.top","root":"/"},"pages":[{"title":"","date":"2020-08-18T14:45:24.731Z","updated":"2020-08-16T01:53:05.449Z","comments":true,"path":"about/index.html","permalink":"https://xckadpym.top/about/index.html","excerpt":"","text":""},{"title":"404","date":"2020-08-17T08:22:14.780Z","updated":"2020-08-17T08:22:14.775Z","comments":true,"path":"/404.html","permalink":"https://xckadpym.top/404.html","excerpt":"","text":"页面未找到！"},{"title":"分类","date":"2020-08-17T08:30:40.764Z","updated":"2020-08-17T04:45:51.669Z","comments":true,"path":"categories/index.html","permalink":"https://xckadpym.top/categories/index.html","excerpt":"","text":""},{"title":"友链","date":"2020-08-17T08:30:46.544Z","updated":"2020-08-17T04:41:39.694Z","comments":true,"path":"friends/index.html","permalink":"https://xckadpym.top/friends/index.html","excerpt":"","text":""},{"title":"归档","date":"2020-08-17T08:30:34.657Z","updated":"2020-08-17T04:41:08.626Z","comments":true,"path":"archives/index.html","permalink":"https://xckadpym.top/archives/index.html","excerpt":"","text":""},{"title":"标签云","date":"2020-08-17T08:31:04.124Z","updated":"2020-08-17T08:31:04.118Z","comments":true,"path":"tags/index.html","permalink":"https://xckadpym.top/tags/index.html","excerpt":"","text":""},{"title":"热门标签","date":"2020-08-17T07:40:47.941Z","updated":"2020-08-17T07:40:47.935Z","comments":true,"path":"blogme/tags/index.html","permalink":"https://xckadpym.top/blogme/tags/index.html","excerpt":"","text":"#C语言"}],"posts":[{"title":"C语言知识总结","slug":"c语言知识总结","date":"2020-08-16T15:17:50.362Z","updated":"2020-08-17T07:36:19.196Z","comments":true,"path":"2020/08/16/cyuyanzhishizongjie/","link":"","permalink":"https://xckadpym.top/2020/08/16/cyuyanzhishizongjie/","excerpt":"文章摘要 关于C语言，后面会持续更新，主要为了方便整理主要涉及C语言 指针 结构体 共用体 项目 C语言二级真题练习这几大模块","text":"文章摘要 关于C语言，后面会持续更新，主要为了方便整理主要涉及C语言 指针 结构体 共用体 项目 C语言二级真题练习这几大模块 一.C语言指针指针基本介绍1.指针是C语言的精华，也是C语言的难点。 2.指针，也就是内存的地址;所谓指针变量，也就是保存了内存地址的变量。 3.获取变量的地址，用&amp;，比如:int num=1,获取num的地址:&amp;num 4.指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值 比如:int *ptr = &num; ptr 就是指向 int 类型的指针变量, 即 ptr 是 int * 类型。 5.获取指针类型所指向的值，使用: * (取值符号)，比如:int * ptr,使用 *ptr获取ptr指向的值 什么是指针 指针是一个变量，其值为另一个变量的地址(前示意图已经说明)，即，内存位置的直接地址。就像其他变量或 常量一样，在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为: int *ip; &#x2F;* 一个整型的指针 *&#x2F; double *dp; &#x2F;* 一个 double 型的指针 *&#x2F; float *fp &#x2F;* 一个浮点型的指针 *&#x2F; char *ch; &#x2F;* 一个字符型的指针 *&#x2F; 指针内存图 指针的算术运算指针是一个用数值表示的地址。可以对指针执行算术运算。可以对指针进行四种算术运算:++、--、+、-。 指针递增操作(++)案例演示#include &lt;stdio.h&gt; const int MAX &#x3D; 3;&#x2F;&#x2F;常量 int main () &#123; int var[] &#x3D; &#123;10, 100, 200&#125;; &#x2F;&#x2F; int 数组 int i, *ptr; &#x2F;&#x2F; ptr 是一个 int*指针 ptr &#x3D; var; &#x2F;&#x2F; ptr 指向了 var 数组的首地址 for ( i &#x3D; 0; i &lt; MAX; i++) &#123; printf(&quot;var[%d] 地址&#x3D; %p \\n&quot;, i, ptr ); printf(&quot;存储值:var[%d] &#x3D; %d\\n&quot;, i, *ptr ); ptr++;&#x2F;&#x2F; ptr &#x3D; ptr + 1(1 个 int 字节数); ptr 存放值+4 字节(int) &#125; getchar(); return 0; &#125; 内存示意图 总结： 数组在内存中是连续分布的 当对指针进行++时，指针会按照它指向的数据类型字节数大小增加，比如 int * 指针，每++ ， 就增加 4 个字指针递减操作(--) 案例演示 include &lt;stdio.h&gt; const int MAX &#x3D; 3; int main () &#123; int var[] &#x3D; &#123;10, 100, 200&#125;; int i, *ptr; &#x2F;* 指针中最后一个元素的地址 *&#x2F; ptr &#x3D; &amp;var[MAX-1]; &#x2F;&#x2F; &amp;var[2] for(i&#x3D;MAX;i&gt;0;i--)&#123;&#x2F;&#x2F; 反向遍历 printf(&quot;ptr 存放的地址&#x3D;%p\\n&quot;, ptr); printf(&quot;存储值:var[%d] &#x3D; %d\\n&quot;, i-1, *ptr ); ptr--; &#x2F;&#x2F; ptr &#x3D; ptr - 1(1 个 int 的字节数 [4 个字节]) &#125; getchar(); return 0; &#125; 小结： 可以对指针按照指定的字节数大小进行 + 或者 – 的操作，可以快速定位你要的地址 指针的比较指针可以用关系运算符进行比较，如 ==、&lt; &lt;= 和 &gt; &gt;=。如果 p1 和 p2 指向两个变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较, 看下面代码，说明输出什么？ 案例1 #include &lt;stdio.h&gt; int main () &#123; int var[] &#x3D; &#123;10, 100, 200&#125;; int *ptr; ptr &#x3D; var;&#x2F;&#x2F;ptr 指向 var 首地址(第一个元素) &#x2F;&#x2F;if(ptr &#x3D;&#x3D; var[0]) &#123;&#x2F;&#x2F;错误,类型不一样 (int *) 和 (int ) &#x2F;&#x2F; printf(&quot;ok1&quot;); &#125; if(ptr &#x3D;&#x3D; &amp;var[0]) &#123; &#x2F;&#x2F; 可以 printf(&quot;\\nok2&quot;); &#x2F;&#x2F;输出 &#125; if(ptr &#x3D;&#x3D; var) &#123; &#x2F;&#x2F;可以 printf(&quot;\\nok3&quot;); &#x2F;&#x2F;输出 &#125; if(ptr &gt;&#x3D; &amp;var[1]) &#123; &#x2F;&#x2F;可以比较,但是返回 false printf(&quot;\\nok4&quot;);&#x2F;&#x2F;不会输出 &#125; getchar(); return 0; &#125; 案例2 #include &lt;stdio.h&gt; const int MAX &#x3D; 3; int main () &#123; int var[] &#x3D; &#123;10, 100, 200&#125;; int i, *ptr; ptr &#x3D; var; i &#x3D; 0; while ( ptr &lt;&#x3D; &amp;var[MAX - 2] )&#x2F;&#x2F;&amp;var[1] &#123; printf(&quot;Address of var[%d] &#x3D; %x\\n&quot;, i, ptr ); printf(&quot;Value of var[%d] &#x3D; %d\\n&quot;, i, *ptr ); ptr++; i++; &#125; &#x2F;&#x2F;会输出 10 , 100 getchar(); return 0; &#125; 运行结果这里补充一点 C语言中 %d, %o, %f, %e, %x 的含义补充说明 ％d整型输出，％ld长整型输出 ％o以八进制数形式输出整数 ％x以十六进制数形式输出整数 ％o以八进制数形式输出整数 ％u以十进制数输出unsigned型数据(无符号数) ％c用来输出一个字符 ％s用来输出一个字符串 ％f用来输出实数，以小数形式输出 ％e以指数形式输出实数 ％g根据大小自动选f格式或e格式 且不输出无意义的零。 指针数组基本介绍要让数组的元素 指向 int 或其他数据类型的地址(指针)。可以使用指针数组 指针数组定义数据类型 *指针数组名[大小]; 比如: int *ptr[3]; // ptr 声明为一个指针数组 | 由 3 个整数指针组成。因此，ptr 中的每个元素，都是一个指向 int 值的指针。 指针数组快速入门 和 内存布局示意图#include &lt;stdio.h&gt; const int MAX&#x3D;3; int main () &#123; int var[] &#x3D; &#123;10, 100, 200&#125;; int i, *ptr[3]; for ( i &#x3D; 0; i &lt; MAX; i++)&#123; ptr[i] &#x3D; &amp;var[i]; &#x2F;* 赋值为整数的地址 *&#x2F; &#125; &#x2F;&#x2F;指针数组来获取各个值 for ( i &#x3D; 0; i &lt; MAX; i++) &#123; printf(&quot;Value of var[%d] &#x3D; %d ptr[%d]本身的地址&#x3D;%p \\n &quot;, i, *ptr[i] , i, &amp;ptr[i]); &#x2F;&#x2F; 10, 100, 200 &#125; getchar(); return 0; &#125; 指针数组的内存布局 指针数组应用实例 请编写程序，定义一个指向字符的指针数组来存储字符串列表(几首你喜欢的歌)，并通过遍历 该指针数组，显 示字符串信息 ， (即:定义一个指针数组，该数组的每个元素，指向的是一个字符串) #include &lt;stdio.h&gt; void main() &#123; &#x2F;&#x2F;定义一个指针数组，该数组的每个元素，指向的是一个字符串 char *song[]&#x3D;&#123; &quot;那些花儿&quot;,&quot;9420&quot;,&quot;下山&quot;,&quot;世间美好与你环环相扣&quot;,&quot;那女孩儿对我说&quot; &#125;; char *pStr&#x3D;&quot;abcde&quot;; &#x2F;&#x2F;遍历指针数组 int i,len&#x3D;5; for(i&#x3D;0;i&lt;len;i++)&#123; printf(&quot;\\nsong[%d]指向的字符串是&#x3D;%s pStr 指向的内容&#x3D;%s&quot;,i,song[i],pStr); &#125; &#125; 运行结果： 指向指针的指针(多重指针)基本介绍 指向指针的指针是一种多级间接寻址的形式，或者说是一个指针链。通常，一个指针包含一个变量的地址。当我们定义一个指向指针的指针时，第一个指针包含了第二个指针的地址，第二个指针指向包含实际值的位置(如下 图): 多重指针(二级,三级)快速入门案例（1） 一个指向指针的指针变量必须如下声明，即在变量名前放置两个星号。例如，下面声明了一个指向 int 类型指针的指针: int **ptr; // ptr 的类型是 int **（2）当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符, 比如 **ptr 案例演示+内存布局图#include &lt;stdio.h&gt; int main () &#123; int var; int *ptr; &#x2F;&#x2F;一级指针 int **pptr; &#x2F;&#x2F;二级指针 int ***ppptr; &#x2F;&#x2F; 三级指针 var &#x3D; 10000; ptr &#x3D; &amp;var; &#x2F;&#x2F; var 变量的地址赋给 ptr pptr &#x3D; &amp;ptr;&#x2F;&#x2F; 表示将 ptr 存放的地址，赋给 pptr ppptr &#x3D; &amp;pptr; &#x2F;&#x2F; 表示将 pptr 存放的地址，赋给 ppptr printf(&quot;var 的地址&#x3D;%p var &#x3D; %d \\n&quot;, &amp;var, var );&#x2F;&#x2F; 0x1122 10000 printf(&quot;ptr 的本身的地址&#x3D;%p ptr 存放的地址&#x3D;%p *ptr &#x3D; %d \\n&quot;, &amp;ptr, ptr, *ptr ); printf(&quot;pptr 本身地址 &#x3D; %p pptr 存放的地址&#x3D;%p **pptr &#x3D; %d\\n&quot;, &amp;pptr, pptr, **pptr); printf(&quot;ppptr 本身地址 &#x3D; %p ppptr 存放的地址&#x3D;%p ***pptr &#x3D; %d\\n&quot;, &amp;ppptr, ppptr, ***ppptr); return 1; &#125; 运行结果： 对应内存图（这是我自己绘的图，大概就是这个流程）： 传递指针(地址)给函数 当函数的形参类型是指针类型时，是使用该函数时，需要传递指针，或者地址，或者数组给该形参 案例 1-传地址或指针给指针变量 代码演示 #include &lt;stdio.h&gt; void test2(int *p); &#x2F;&#x2F;函数声明，接收 int * void main() &#123; int num&#x3D;90; int *p &#x3D; &amp;num; &#x2F;&#x2F;将 num 的地址赋给 p test2(&amp;num); &#x2F;&#x2F;传地址 printf(&quot;\\nmain() 中的 num&#x3D;%d&quot;, num); &#x2F;&#x2F; num &#x3D; 91 test2(p); &#x2F;&#x2F;传指针 printf(&quot;\\nmain() 中的 num&#x3D;%d&quot;, num);&#x2F;&#x2F; num &#x3D; 92 &#125; void test2(int *p) &#123; *p +&#x3D; 1; &#x2F;&#x2F;*p 就访问 num 的值 &#125; 案例 2-传数组给指针变量数组名本身就代表该数组首地址，因此传数组的本质就是传地址。 #include &lt;stdio.h&gt; double getAverage(int *arr, int size); &#x2F;&#x2F;函数声明 int main ()&#123; int balance[5] &#x3D; &#123;1000, 2, 3, 17, 50&#125;; &#x2F;* 带有 5 个元素的整型数组 *&#x2F; double avg; &#x2F;* 传递一个指向数组的指针作为参数 *&#x2F; avg &#x3D; getAverage( balance, 5 ) ; &#x2F;* 输出返回值 *&#x2F; printf(&quot;Average value is: %f\\n&quot;, avg ); return 0; &#125; double getAverage(int *arr, int size)&#123; int i, sum &#x3D; 0; double avg; for (i &#x3D; 0; i &lt; size; ++i)&#123; sum +&#x3D; arr[i];&#x2F;&#x2F; arr[0] &#x3D;&gt;数组第一个元素的地址 arr[1] printf(&quot;\\narr 存放的地址&#x3D;%p &quot;, arr); &#125; avg &#x3D; (double)sum &#x2F; size; return avg; &#125; 运行结果 画个内存图吧，好吧整一个 其实看着这段代码，这么大一片，感觉有点复杂，其实很简单，上面我也花了内存图，我来解释一下，首先就是 申明一个函数，当然这个函数可以在main（）函数里面，也可以在main函数外面（本段案例就是在main函数之外申明的）， 如果🚫不想申明函数，就把自定义函数放在main函数前面，这段代码主要是通过定义一个数组，把他的地址指向一个指针， 用过double getAverage（）这个自定义函数，传递指针地址，并且求这个数组存放的元素的平均值，并赋值给avg。 通过这个案例，我们就可以很详细的明白 传数组给指针变量 的一个过程 返回指针的函数请编写一个函数 strlong()，返回两个字符串中较长的一个。 #include &lt;stdio.h&gt; #include &lt;string.h&gt; char *strlong(char *str1, char *str2)&#123; &#x2F;&#x2F;函数返回的 char * (指针) printf(&quot;\\nstr1 的长度%d str2 的长度%d&quot;, strlen(str1), strlen(str2)); if(strlen(str1) &gt;&#x3D; strlen(str2))&#123; return str1; &#125;else&#123; return str2; &#125; &#125; int main()&#123; char str1[30], str2[30], *str; &#x2F;&#x2F;str 是一个指针类型，指向一个字符串 printf(&quot;\\n 请输入第1个字符串&quot;); gets(str1); printf(&quot;\\n 请输入第2个字符串&quot;); gets(str2); str &#x3D; strlong(str1, str2); printf(&quot;\\nLonger string: %s \\n&quot;, str); return 0; &#125; 运行结果 指针函数注意事项和细节","categories":[{"name":"学习","slug":"学习","permalink":"https://xckadpym.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://xckadpym.top/tags/c%E8%AF%AD%E8%A8%80/"}]},{"title":"C语言二级题目","slug":"c语言二级题目","date":"2020-08-16T15:17:28.210Z","updated":"2020-08-18T23:38:16.557Z","comments":true,"path":"2020/08/16/cyuyanerjitimu/","link":"","permalink":"https://xckadpym.top/2020/08/16/cyuyanerjitimu/","excerpt":"文章摘要 今天开始分享未来教育C语言二级真题","text":"文章摘要 今天开始分享未来教育C语言二级真题 （注：这些都是我自己的方法，可能有一些错误，如果大家发现错误，欢迎大家O(∩_∩)O吐槽~ 指正）一.真考试卷1 源代码 #include&lt;string.h&gt; #include&lt;stdio.h&gt; #define N 80 int fun(char *s) &#123; &#125; void main() &#123; FILE *wf; char line[N]; int num&#x3D;0; printf(&quot;Enter a string:\\n &quot;); gets(line); num&#x3D;fun(line); printf(&quot;The number of word is:%d\\n\\n &quot;,num); &#x2F;******************************&#x2F; wf&#x3D;fopen(&quot;out.dat&quot;,&quot;w&quot;); fprintf(wf,&quot;%d&quot;,fun(&quot;a big car&quot;)); fclose(wf); &#x2F;*****************************&#x2F; &#125; 参考答案 我的方法一int fun (char *s)&#123; char *p&#x3D;NULL; &#x2F;&#x2F;首先定义一个char型指针类型变量，并赋初始值，这一点很重要 int i, j; j&#x3D;1; p&#x3D;s; for (i&#x3D;0;i&lt;80;i++) &#123; &#x2F;&#x2F;这里i&lt;80主要我觉得N define为80， 就按最大的 *p++; &#x2F;&#x2F;代表每次增加4个字节，取下一-位字符 if(*p&#x3D;&#x3D;’&#39;)&#123; j++; &#125; return j; &#125; 运行结果 方法二int fun (char *s)&#123; char str[80]; j&#x3D;1; strcpy(str,s); &#x2F;&#x2F;将字符串s拷贝到str，剩余跟上面差不多 for(i&#x3D;0;i&lt;80;i++)&#123; if(str[i]&#x3D;&#x3D;&#39; &#39;)&#123; j++; &#125; &#125; return j; &#125; 运行结果 二.真考试卷2 源代码#include&lt;stdio.h&gt; #include&lt;string.h&gt; #include&lt;conio.h&gt; #include&lt;stdlib.h&gt; #define N 10 typedef struct ss &#123; char num[10]; int s; &#125; STU; void fun(STU a[], STU *s) &#123; &#125; void main() &#123; FILE *wf; STU a[N]&#x3D;&#123;&#123; &quot;A01&quot;,81&#125;,&#123; &quot;A02&quot;,89&#125;,&#123; &quot;A03&quot;,66&#125;,&#123; &quot;A04&quot;,87&#125;,&#123; &quot;A05&quot;,77&#125;, &#123; &quot;A06&quot;,90&#125;,&#123; &quot;A07&quot;,79&#125;,&#123; &quot;A08&quot;,61&#125;,&#123; &quot;A09&quot;,80&#125;,&#123; &quot;A10&quot;,71&#125;&#125;,m; int i; system(&quot;CLS&quot;); printf(&quot;*****The original data*****\\n&quot;); for(i&#x3D;0;i&lt;N;i++) printf(&quot;No&#x3D;%s Mark&#x3D;%d\\n&quot;, a[i].num,a[i].s); fun(a,&amp;m); printf(&quot;*****THE RESULT*****\\n&quot;); printf(&quot;The lowest :%s, %d\\n&quot;,m.num,m.s); &#x2F;******************************&#x2F; wf&#x3D;fopen(&quot;out.dat&quot;,&quot;w&quot;); fprintf(wf,&quot;%s, %d&quot;,m.num,m.s); fclose(wf); &#x2F;*****************************&#x2F; &#125; 参考答案 我的方法 使用冒泡排序算法求解&gt;void fun(STU a[], STU *s) &#123; int i,j; for(i&#x3D;0;i&lt;N;i++)&#123; for(j&#x3D;0;j&lt;N-i;j++)&#123; if(a[i].s&gt;a[j].s)&#123; int temp; temp&#x3D;a[i].s; a[i].s&#x3D;a[j].s; a[j].s&#x3D;temp; *s&#x3D;a[i]; &#125; &#125; &#125; &#x2F;* 我这里使用了冒泡排序算法，因为我没有学过链表，而且我觉得一般C语言二级链表考的少 大家把这个冒泡排序算法记住即可，值得注意的是 这里定义的结构体typedef struct ss STU s变量是int类型，所以最后冒泡排序中应该是a[i].s *&#x2F; &#125; 运行结果 三.真考试卷3真题试题三，答案给的详细，这里贴上题目和参考答案 参考答案 四.真考试卷4 参考答案源代码#include&lt;stdio.h&gt; #include&lt;conio.h&gt; #include&lt;stdlib.h&gt; #define N 5 double fun (int w[][N]) &#123; &#125; void main() &#123; FILE *wf; int a[N][N]&#x3D;&#123;0,1,2,7,9,1,9,7,4,5,2,3,8,3,1,4,5,6,8,2,5,9,1,4,1&#125;; int i, j; double s; system(&quot;CLS&quot;); printf(&quot;*****The array*****\\n &quot;); for (i&#x3D;0; i&lt;N; i++) &#123; for (j&#x3D;0;j&lt;N;j++) &#123;printf(&quot;%4d &quot;,a[i][j]);&#125; printf(&quot;\\n &quot;); &#125; s&#x3D;fun(a); printf(&quot;*****THE RESULT*****\\n &quot;); printf(&quot;The sum is : %lf\\n &quot;,s); &#x2F;******************************&#x2F; wf&#x3D;fopen(&quot;out.dat&quot;,&quot;w&quot;); fprintf (wf,&quot;%lf&quot;,s); fclose(wf); &#x2F;*****************************&#x2F; &#125; 我的方法double fun (int w[][N]) &#123; int i,j; double s&#x3D;0; double res; for(i&#x3D;0;i&lt;N;i++)&#123; for(j&#x3D;0;j&lt;N;j++)&#123; if(j&#x3D;&#x3D;0||j&#x3D;&#x3D;4)&#123; s+&#x3D;w[i][j]; &#125;else if(i&#x3D;&#x3D;0||i&#x3D;&#x3D;4)&#123; s&#x3D;s+w[i][j+1]; &#125; &#125; &#125; res&#x3D;s&#x2F;16; return res; &#125; 运行结果","categories":[{"name":"学习","slug":"学习","permalink":"https://xckadpym.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"二级C","slug":"二级C","permalink":"https://xckadpym.top/tags/%E4%BA%8C%E7%BA%A7C/"}]},{"title":"hexo将博客部署到腾讯云服务器","slug":"hexo+ubuntu将博客部署到腾讯云服务器","date":"2020-08-05T06:16:37.031Z","updated":"2020-08-17T08:33:24.018Z","comments":true,"path":"2020/08/05/hexoubuntujiangbokebushudaotengxunyunfuwuqi/","link":"","permalink":"https://xckadpym.top/2020/08/05/hexoubuntujiangbokebushudaotengxunyunfuwuqi/","excerpt":"文章摘要 将hexo个人博客部署到个人云服务器 很多朋友们，将博客搭建到了github，有感觉不太友好，访问速度实在太慢，那么就会想到，腾讯云新人福利还是蛮优惠的，想来搞一波，；练练手。好吧废话不多说，开整，我通过把我的经验分享给大家，我尽量写得简洁，长话短说，希望大家少踩坑","text":"文章摘要 将hexo个人博客部署到个人云服务器 很多朋友们，将博客搭建到了github，有感觉不太友好，访问速度实在太慢，那么就会想到，腾讯云新人福利还是蛮优惠的，想来搞一波，；练练手。好吧废话不多说，开整，我通过把我的经验分享给大家，我尽量写得简洁，长话短说，希望大家少踩坑 hexo搭建到本地的过程，这里我就略过了，详细请看这位博主的他写的很详细了点击这里 获取体验产品--服务器（这个根据你自己的爱好，阿里云，腾讯云，华为云等等都OK) 域名购买，申请，备案这个取决于你自己 下面就是重点了1.我们有了服务器后，就要通过ssh服务连接，让后操作，我们第一步就弄好吧，我一般喜欢 dibian， Ubuntu 2.修改为root权限sudo passwd root 输入密码，可以和 ubuntu 密码一致，也可以修改 (密码会让你输入两次) 修改 ssh 配置sudo vi /etc/ssh/sshd_config 修改 PermitRootLogin 进入 ssh 配置界面后找到PermitRootLogin，将它后面改为yes，保存 (按i进入编辑模式，编辑完esc退出，:wq) 重启 ssh 服务 sudo service ssh restart 四.下面就是用xshell，或者finalshell 用root登陆即可 服务器配置hexo安装sudo apt-get install npm npm install hexo-cli hexo-server -g git配置1.安装git sudo apt-get install git 2.安装nginx apt-get update apt-get install git nginx -y 3.创建git仓库 sudo mkdir /var/www/git 4.修改权限： chown -R $USER:$USER /var/www/git chmod -R 755 /var/www/git 创建远程 Git 仓库：(当然这个看你，我是建在nginx站点目录，/var/www/hexo,你也可以建在/home文件夹下，都可以) cd /var/www/git git init --bare {自定义仓库名name}.git git init --bare myblog.git 创建 Git 钩子（hooks)/var/www/git目录下创建一个新的钩子文件： vim /var/www/git/myblog.git/hooks/post-receive 打开文件后，加入下面的代码： git --work-tree=/var/www/git --git-dir=/var/www/git/myblog.git checkout -f 将文件保存后，赋予该文件可执行权限： chmod +x /var/www/git/myblog.git/hooks/post-receive 配置 Nginx 托管文件目录mkdir -p /var/www/hexo chown -R $USER:$USER /var/www/hexo chmod -R 755 /var/www/hexo 修改 Nginx 的 default 文件使得 root 指向刚刚创建的 /var/www/hexo目录： vim /etc/nginx/sites-available/default root /var/www/html 改成 /var/www/hexo 最后重启 nginx 服务: service nginx restart 使用 Git 部署本地 Hexo 到远端服务器打开你的站点配置文件_config.yml 修改 URL和repo 就可以了将你的repo改成repo: root@{你的服务器ip地址}:/var/www/git/myblog.git 最后 ，hexo clean，hexo g , hexo d 上传即可， 当然很多人会在这一步失败， SSH连接报错:Permission denied, please try again. 这是因为你没有开启root权限， 还有就是 要将密钥添加到 git 用户下： 反正一步一步来，就不会出错，我这里就不详细举例了 这差不多就打工搞成了","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://xckadpym.top/tags/hexo/"}],"author":"小菜"}],"categories":[{"name":"学习","slug":"学习","permalink":"https://xckadpym.top/categories/%E5%AD%A6%E4%B9%A0/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://xckadpym.top/tags/c%E8%AF%AD%E8%A8%80/"},{"name":"二级C","slug":"二级C","permalink":"https://xckadpym.top/tags/%E4%BA%8C%E7%BA%A7C/"},{"name":"hexo","slug":"hexo","permalink":"https://xckadpym.top/tags/hexo/"}]}